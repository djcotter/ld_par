"""The purpose of this script is to take pairwise LD output from plink and calculate average LD in set windows
	Updated: 3/15/17
	Daniel Cotter
"""

from sys import argv
import csv

############################
## Set argument variables ##
############################
""" input file: pairwise LD file generated by plink using the command 'with-freqs'
	windows: bed file with desired windows for the analysis
	ld_bin_size: length in either direction from teh focal position in which we should consider LD (in kilobases)
	analysis type: type of summary file to be generated using the desired options
	output_file: path to an output file
"""
script, input_file, windows, ld_bin_size = argv
#script, input_file, windows, ld_bin_size, analysis_type, output_file = argv


######################################################
## Read in windows file and set starting conditions ##
######################################################
# Open the window file as bed coordinates so that every window_coordinates[i][1] corresponds to the start position and [2] to the end position.
with open(windows, 'rU') as f:
	window_coordinates = list(csv.reader(f, delimiter = '\t'))
	for window in window_coordinates:
			window[1] = float(window[1])
			window[2] = float(window[2]) 
			del window[3]

win_num = 0 
windows = window_coordinates[win_num]
R2_values = {}
reciprocal_R2 = {} #The information that is stored as pairwise is not duplicated. We have to create a matrix that contains values for BP_B > window[i][2] but BP_B - BP_A < ld_bin
ld_bin = float(ld_bin_size) * 1000
fp = 0 #initalize the focal position as 0
results = [] # initialize an empty results list


###########################################
## Functions for compiling summary stats ##
###########################################
def mean_LD(window_LD_dictionary):
	"""Calculate mean LD in a window by taking all focal positions and their associated distance and R2 values
		The structure of the data is {fp: [[distance, R2], [distance, R2] ...]}
	"""
	sum_LD = 0
	num_sites = 0
	for focal_position in window_LD_dictionary:
		for pair in focal_position:
			sum_LD += pair[0]
			num_sites += 1
	mean_LD = sum_LD/num_sites
	return mean_LD



############################################################
## Open the LD file and perform the analysis line by line ##
############################################################
with open(input_file, 'rU') as f:
	for line in f:
		row = line.split()
		
		# skip the header line of the file
		if row[0] == 'CHR_A':
			continue

		# initializes the focal position for the first line of the file	
		if fp == 0: 
			fp = float(row[1])
			R2_values[fp] = []
			LD_bin = [fp - ld_bin, fp + ld_bin]

		# change script paramaters and initialize a new list when reaching a new focal position
		elif float(row[1]) != fp: 
			fp = float(row[1])
			R2_values[fp] = []
			LD_bin = [fp - ld_bin, fp + ld_bin]

		# if the site being compared is within ld_bin of the focal position, store the distance and R2 value in the dictionary as a list
		if (float(row[5]) <= LD_bin[1]) and (float(row[5] >= LD_bin[0])):
			R2_values[fp].append([float(row[5])-float(row[1]), float(row[8])])
		
		# if the site in position 2 lies outside the current window, but (BP_B - BP_A) lies within LD_bin, we need to save that information for analyses of future windows
		if (float(row[5]) > windows[2]) and (abs(float(row[5]) - float(row[1])) < ld_bin):
			if float(row[5]) in reverse_R2:
				reverse_R2[float(row[5])].append([float(row[5])-float(row[1]), float(row[8])])
			else:
				reverse_R2[float(row[5])] = [[float(row[5])-float(row[1]), float(row[8])]]

		# check the reverse list to see if there are any saved data for the current focal position, then combine the two lists
		if fp in reverse_R2:
			R2_values[fp] = R2_values[fp] + reverse_R2[fp]

		#if the focal position lies outside of the current window, change the window index and calculate a summary statistic
		if fp > windows[2]:

			win_num += 1
			windows = window_coordinates[win_num]
